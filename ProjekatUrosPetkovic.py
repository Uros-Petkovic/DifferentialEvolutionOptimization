# -*- coding: utf-8 -*-
"""ProjekatUros.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WnCRMe7capWcnkUIZutSK1slksD23IkN

#Polinom devetog stepena, cost funkcija L2 norma i L_infinity norma

f(x1,x2,x3,x4)~
(a0+a1x1+a2x1^2+a3x1^3+a4x1^4+a5x^5+a6x^6+a7x^7+a8x^8+a9x^9)*
(b0+b1x2+b2x2^2+b3x2^3+b4x2^4+b5x^5+b6x^6+b7x^7+b8x^8+b9x^9)*
(c0+c1x3+c2x3^2+c3x3^3+c4x3^4+c5x^5+c6x^6+c7x^7+c8x^8+c9x^9)*
(d0+d1x4+d2x4^2+d3x4^3+d4x4^4+d5x^5+d6x^6+d7x^7+d8x^8+d9x^9)
"""

import numpy as np
from matplotlib import pyplot as plt
import math

Npop=50  #Biramo velicinu populacije 50
Cr=0.9   #Potrebne konstante
F=0.8
D=40  #Broj promenljivih
N=300  #Broj ulaza
podaci=np.loadtxt('training_300_G.txt')   #Ucitavanje podataka
X=np.zeros(shape=(N,4))
Y=np.zeros(shape=(N,1))
X=podaci[:,1:5]
Y=podaci[:,5].reshape(1,-1)

#Funkcija za racunanje izlaza najboljih parametara (polinoma)
def izlazplot(X,Resenje):
  Xpol1=np.array([1 ,X[0] ,X[0]**2, X[0]**3, X[0]**4, X[0]**5, X[0]**6, X[0]**7, X[0]**8, X[0]**9])
  Xpol2=np.array([1, X[1], X[1]**2, X[1]**3, X[1]**4, X[1]**5, X[1]**6, X[1]**7, X[1]**8, X[1]**9])
  Xpol3=np.array([1, X[2], X[2]**2, X[2]**3, X[2]**4, X[2]**5, X[2]**6, X[2]**7, X[2]**8, X[2]**9])
  Xpol4=np.array([1 ,X[3], X[3]**2 ,X[3]**3, X[3]**4, X[3]**5, X[3]**6, X[3]**7, X[3]**8, X[3]**9])
  f1=np.dot(Xpol1,Resenje[0:10].transpose())
  f2=np.dot(Xpol2,Resenje[10:20].transpose())
  f3=np.dot(Xpol3,Resenje[20:30].transpose())
  f4=np.dot(Xpol4,Resenje[30:40].transpose())
  izlaz=np.multiply(np.multiply(np.multiply(f1,f2),f3),f4)
  return izlaz.transpose()

#Funkcija za racunanje polinomijalne funkcije
def izlaz(X,VectorS):
  Xpol1=np.array([1 ,X[0] ,X[0]**2, X[0]**3, X[0]**4, X[0]**5, X[0]**6, X[0]**7, X[0]**8, X[0]**9])
  Xpol2=np.array([1, X[1], X[1]**2, X[1]**3, X[1]**4, X[1]**5, X[1]**6, X[1]**7, X[1]**8, X[1]**9])
  Xpol3=np.array([1, X[2], X[2]**2, X[2]**3, X[2]**4, X[2]**5, X[2]**6, X[2]**7, X[2]**8, X[2]**9])
  Xpol4=np.array([1 ,X[3], X[3]**2 ,X[3]**3, X[3]**4, X[3]**5, X[3]**6, X[3]**7, X[3]**8, X[3]**9])
  f1=np.dot(Xpol1,VectorS[:,0:10].transpose())
  f2=np.dot(Xpol2,VectorS[:,10:20].transpose())
  f3=np.dot(Xpol3,VectorS[:,20:30].transpose())
  f4=np.dot(Xpol4,VectorS[:,30:40].transpose())
  izlaz=np.multiply(np.multiply(np.multiply(f1,f2),f3),f4)
  return izlaz.transpose()

#Funkcija koja racuna vrednost L2 norme
def costL2(X,Y):
    return np.sqrt(np.sum(np.power(X-Y,2),axis=1))

#Funkcija koja racuna vrednost Linfinity norme
def costInfinity(X,Y):
  return np.max(np.absolute(X-Y),axis=1)

Fniz=np.zeros(shape=(10,1000))  #Pravim niz koji cuva sve vrednosti kriterijumske funkcije
minvrednost=np.zeros(shape=(10,1))   #Minimalne vrednosti za svako pokretanje algoritma
Resenje=np.empty(shape=(D,10))   #Najbolja resenja za svaki algoritam
for t in range(0,10):
  iter=0
  kraj=0
  VectorS=np.empty(shape=(Npop,D))   #Vektor populacije trazenih parametara
  VectorN=np.empty(shape=(Npop,D))
  for i in range(0,Npop):
    for j in range(0,D):
      VectorS[i,j]=np.random.uniform(-1,1)  #Random uniformno generisanje pocetnih parametara
  minimum=1e10
  youtS=np.empty(shape=(Npop,N))    #Definisanje izlaza, odnosno polinomijalne funkcije
  youtN=np.empty(shape=(Npop,N))
  while (iter<1000 and kraj==0):
    for j in range(0,N):
      youtS[:,j]=izlaz(X[j,:],VectorS)   #Racunanje polinoma
    f=costL2(youtS,Y)                    #Racunanje cost funkcije
    if (min(f)<minimum):
      minimum=min(f)                     #Ako je trenutni pronadjeni minimum manji od dosadasnjeg, sacuvaj ga
      minvrednost[t]=minimum
      Fniz[t,iter]=minimum
      index=np.argmin(f)
      Resenje[:,t]=VectorS[index,:]
      if minimum<5:                      #Ako si pronasao zeljenu vrednost, izadji iz algoritma
        kraj=1
        break
    else:
      Fniz[t,iter]=minimum

    for i in range(0,Npop):   #Selekcija
      a=i
      while (a==i):
        a=math.floor(np.random.rand()*Npop)   #Generisanje 3 razlicita broja za selekciju
      b=a
      while (b==a or b==i):
        b=math.floor(np.random.rand()*Npop)
      c=b
      while (c==b or c==a or c==i):
        c=math.floor(np.random.rand()*Npop)
      R=math.floor(np.random.rand()*D) #Promenljiva pod rednim brojem R ce biti sigurno zamenjena

      for j in range(0,D):
        ri=np.random.rand()
        x=VectorS[i,j]
        z=VectorS[a,j] + F*(VectorS[b,j]-VectorS[c,j])   #Generisanje novog resenja
        if (ri<Cr or j==R):
          VectorN[i,j]=z      #Usvajanje ako je ispunjen uslov
        else:
          VectorN[i,j]=x
        if VectorN[i,j]<-1:
          VectorN[i,j]=-1
        if VectorN[i,j]>1:    #Obezbedjivanje da parametri pripadaju domenu
          VectorN[i,j]=1
  

    for j in range(0,N):
      youtN[:,j]=izlaz(X[j,:],VectorN)   #Racunanje novog izlaza
    fN=costL2(youtN,Y)    #Racunanje nove cost funkcije
    if (min(fN)<minimum):
      minimum=min(fN)
      minvrednost[t]=minimum   #Cuvanje novog minimuma
      Fniz[t,iter]=minimum
      index=np.argmin(fN)
      Resenje[:,t]=VectorN[index,:]
      if minimum<5: #33.7 granica za L2   8.74 granica za L infinity
        kraj=1
        break
    else:
      Fniz[t,iter]=minimum
    for k in range(0,Npop):    #Upisivanje boljih vrednosti u populaciju koja nastavlja dalji tok
      if f[k]<fN[k]:
        VectorN[k,:]=VectorS[k,:]
    VectorS=np.copy(VectorN)
    iter=iter+1
    #print(iter)
    #print(minimum)



indexminimum=np.argmin(minvrednost)
ResenjeKon=Resenje[:,indexminimum]     #Najbolje resenje ikada
yout=np.empty(shape=(300,1))
for j in range(0,300):
  yout[j]=izlazplot(X[j,:],ResenjeKon)   #Racunanje cost funkcije
fout=costL2(yout.transpose(),Y)
print("Niz parametara koji daje najmanje resenje: "+str(ResenjeKon))
print("Pronadjeni minimum cost funkcije je: "+str(min(fout)))

plt.figure()
plt.plot(np.arange(1,1001,1),Fniz.transpose())    #Prikaz potrebnih grafika
plt.xlabel('Iteracije')
plt.ylabel('Vrednost cost funkcije')
plt.title('10 pokretanja algoritma L2 norme 9. stepen')

Fmean=np.mean(Fniz,axis=0)
Fminpokretanje=np.min(Fniz,axis=1)

plt.figure()
plt.plot(np.arange(1,1001,1),Fmean.transpose())
plt.xlabel('Iteracije')
plt.ylabel('Vrednost cost funkcije')
plt.title('Srednja vrednost L2 norme 10 pokretanja 9. stepen')

plt.figure()
plt.plot(np.arange(1,11,1),Fminpokretanje)
plt.xlabel('Pokretanja')
plt.ylabel('Vrednost cost funkcije')
plt.title('Minimalna vrednost L2 norme sva pokretanja 9. stepen')

# ZAKLJUCCI
#L infinity 8.74 249. iteracija, 1000 iteracija 8.72
#L2 33.7 366. iteracija, 1000 iteracija 33.31

"""#Polinom cetvrtog stepena, cost funkcija L2 norma i L_infinity norma

f(x1,x2,x3,x4)~
(a0+a1x1+a2x1^2+a3x1^3+a4x1^4)*
(b0+b1x2+b2x2^2+b3x2^3+b4x2^4)*
(c0+c1x3+c2x3^2+c3x3^3+c4x3^4)*
(d0+d1x4+d2x4^2+d3x4^3+d4x4^4)
"""

import numpy as np
from matplotlib import pyplot as plt
import math

Npop=50  #Definisanje velicine populacije
Cr=0.9   #Definisanje potrebnih konstanti
F=0.8
D=20    #Broj promenljivih
N=300   #Broj ulaza
podaci=np.loadtxt('training_300_G.txt')  #Ucitavanje podataka
X=np.zeros(shape=(N,4))
Y=np.zeros(shape=(N,1))
X=podaci[:,1:5]
Y=podaci[:,5].reshape(1,-1)

#Funkcija za racunanje krajnjeg izlaza, odnosno polinoma
def izlazplot(X,Resenje):
  Xpol1=np.array([1 ,X[0] ,X[0]**2, X[0]**3, X[0]**4])
  Xpol2=np.array([1, X[1], X[1]**2, X[1]**3, X[1]**4])
  Xpol3=np.array([1, X[2], X[2]**2, X[2]**3, X[2]**4])
  Xpol4=np.array([1 ,X[3], X[3]**2 ,X[3]**3, X[3]**4])
  f1=np.dot(Xpol1,Resenje[0:5].transpose())
  f2=np.dot(Xpol2,Resenje[5:10].transpose())
  f3=np.dot(Xpol3,Resenje[10:15].transpose())
  f4=np.dot(Xpol4,Resenje[15:20].transpose())
  izlaz=np.multiply(np.multiply(np.multiply(f1,f2),f3),f4)
  return izlaz.transpose()

#Funkcija za racunanje polinomijalne funkcije
def izlaz(X,VectorS):
  Xpol1=np.array([1 ,X[0] ,X[0]**2, X[0]**3, X[0]**4])
  Xpol2=np.array([1, X[1], X[1]**2, X[1]**3, X[1]**4])
  Xpol3=np.array([1, X[2], X[2]**2, X[2]**3, X[2]**4])
  Xpol4=np.array([1 ,X[3], X[3]**2 ,X[3]**3, X[3]**4])
  f1=np.dot(Xpol1,VectorS[:,0:5].transpose())
  f2=np.dot(Xpol2,VectorS[:,5:10].transpose())
  f3=np.dot(Xpol3,VectorS[:,10:15].transpose())
  f4=np.dot(Xpol4,VectorS[:,15:20].transpose())
  izlaz=np.multiply(np.multiply(np.multiply(f1,f2),f3),f4)
  return izlaz.transpose()

#Funkcija za racunanje L2 norme
def costL2(X,Y):
    return np.sqrt(np.sum(np.power(X-Y,2),axis=1))

#Funkcija za racunanje Linfinity norme
def costInfinity(X,Y):
  return np.max(np.absolute(X-Y),axis=1)

Fniz=np.zeros(shape=(10,1000))  #Niz svih vrednosti cost funkcije
minvrednost=np.zeros(shape=(10,1))  #Niz svih vrednosti minimuma za svako pokretanje
Resenje=np.empty(shape=(D,10))   #Niz najboljih resenja za svako pokretanje
for t in range(0,10):
  iter=0
  kraj=0
  VectorS=np.empty(shape=(Npop,D))  #Populacija promenljivih
  VectorN=np.empty(shape=(Npop,D))
  for i in range(0,Npop):
    for j in range(0,D):
      VectorS[i,j]=np.random.uniform(-1,1)  #Random generisanje pocetne populacije uniformno
  minimum=1e10
  youtS=np.empty(shape=(Npop,N))   #Niz izlaza
  youtN=np.empty(shape=(Npop,N))
  while (iter<1000 and kraj==0):
    for j in range(0,N):
      youtS[:,j]=izlaz(X[j,:],VectorS)  #Racunanje polinomijalne funkcije
    f=costL2(youtS,Y)  #Racunanje cost funkcije
    if (min(f)<minimum):
      minimum=min(f)
      minvrednost[t]=minimum   #Usvajanje trenutnog minimuma
      Fniz[t,iter]=minimum
      index=np.argmin(f)
      Resenje[:,t]=VectorS[index,:]
      if minimum<5:
        kraj=1
        break
    else:
      Fniz[t,iter]=minimum

    for i in range(0,Npop):   #Selekcija
      a=i
      while (a==i):
        a=math.floor(np.random.rand()*Npop)  #Biranje 3 random razlicita broja
      b=a
      while (b==a or b==i):
        b=math.floor(np.random.rand()*Npop)
      c=b
      while (c==b or c==a or c==i):
        c=math.floor(np.random.rand()*Npop)
      R=math.floor(np.random.rand()*D)

      for j in range(0,D):
        ri=np.random.rand()  #Racunanje novog parametra
        x=VectorS[i,j]
        z=VectorS[a,j] + F*(VectorS[b,j]-VectorS[c,j])
        if (ri<Cr or j==R):
          VectorN[i,j]=z   #Prihvatanje novog parametra u zavisnosti od uslova
        else:
          VectorN[i,j]=x
        if VectorN[i,j]<-1:
          VectorN[i,j]=-1
        if VectorN[i,j]>1:
          VectorN[i,j]=1
  

    for j in range(0,N):
      youtN[:,j]=izlaz(X[j,:],VectorN)  #Racunanje novog izlaza
    fN=costL2(youtN,Y)   #Racunanje nove cost funkcije
    if (min(fN)<minimum):
      minimum=min(fN)
      minvrednost[t]=minimum  #Usvajanje novog minimuma
      Fniz[t,iter]=minimum
      index=np.argmin(fN)
      Resenje[:,t]=VectorN[index,:]
      if minimum<5: #33.56 L2  8.81 L infinity
        kraj=1
        break
    else:
      Fniz[t,iter]=minimum
    for k in range(0,Npop):
      if f[k]<fN[k]:
        VectorN[k,:]=VectorS[k,:]  #Zadrzavanje boljih resenja za sledecu iteraciju
    VectorS=np.copy(VectorN)
    iter=iter+1
    #print(iter)
    #print(minimum)



indexminimum=np.argmin(minvrednost)
ResenjeKon=Resenje[:,indexminimum]   #Uzimanje najboljeg resenja ikada
yout=np.empty(shape=(300,1))
for j in range(0,300):
  yout[j]=izlazplot(X[j,:],ResenjeKon)  #Racunanje izlaza za najbolje resenje
fout=costL2(yout.transpose(),Y)   #Racunanje cost funkcije za najbolje resenje
print("Niz parametara koji daje najmanje resenje: "+str(ResenjeKon))
print("Pronadjeni minimum cost funkcije je: "+str(min(fout)))

plt.figure()
plt.plot(np.arange(1,1001,1),Fniz.transpose())   #Prikaz potrebnih grafika
plt.xlabel('Iteracije')
plt.ylabel('Vrednost cost funkcije')
plt.title('10 pokretanja algoritma L2 norme 4. stepen')

Fmean=np.mean(Fniz,axis=0)
Fminpokretanje=np.min(Fniz,axis=1)

plt.figure()
plt.plot(np.arange(1,1001,1),Fmean.transpose())
plt.xlabel('Iteracije')
plt.ylabel('Vrednost cost funkcije')
plt.title('Srednja vrednost L2 norme 10 pokretanja 4. stepen')

plt.figure()
plt.plot(np.arange(1,11,1),Fminpokretanje)
plt.xlabel('Pokretanja')
plt.ylabel('Vrednost cost funkcije')
plt.title('Minimalna vrednost L2 norme sva pokretanja 4. stepen')

# ZAKLJUCCI

#L infinity 8.81 112. iteracija, 1000 iteracija 8.79
#L2  33.56 299. iteracija, 1000 iteracija 33.53